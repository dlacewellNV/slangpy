### Cluster Acceleration Structure – Working Plan

## High-level outline
- Goal: Add portable cluster acceleration structure support to `slang-rhi` and `sgl`, OptiX backend first. No device-side copies for indirect args.
- Feature gates:
  - Core clusters and templates: “cluster-acceleration-structure” (in the existing ray tracing section)
- MVP scope:
  - Build types: CLASFromTriangles, BLASFromCLAS
  - Include unstructured TemplatesFromTriangles and CLASFromTemplates in headers now (core feature), implement in a follow-up local stage
  - Exclude structured grid clusters (OptiX-only) from common API for now

## CRITICAL: device-args ABI (zero‑copy)
- ABI objects in device buffers; backends forward them without per-field translation.
- Fixed-stride, trivially copyable PODs with explicit alignment/padding; only scalars and 64‑bit device addresses.
- Single cross-backend definition (OptiX/Vulkan/DX share the same layout). Match the driver ABI bitwise.
- No C/C++ bitfields. Use packed integers (`u32`/`u64`) with SHIFT/MASK helpers (host/device share the same constants).
- Headers: one device-only header (`cluster_accel_abi.slang`) defines structs + pack/unpack. Host treats buffers as opaque. Optional tiny host mirror for tests/tools only.
- OMM-related fields present in vendor ABIs must be zero in MVP.
- Host-side Desc `next`: allowed on host Desc only; in MVP must be null; unknown → UnsupportedExtension. Device-args never include `next`.
- Kernels write args; insert a UAV/global barrier before the build that consumes them; ensure buffer visibility for the backend.

## Session checklist (tick as you go)
- [X] Step 1: RHI headers — compile-only
  - Acceptance: headers compile; device/encoder stubs link; feature name recognized
- [X] Step 2: sgl headers — compile-only
  - Acceptance: sgl compiles; converter builds; encoder exposes method
- [X] Step 3: Feature wiring — defaults off
  - Acceptance: feature registered in RHI and mirrored in sgl; defaults off
- [X] Step 4: OptiX backend — clusters MVP
  - Acceptance: sizes/build for triangles→clusters and clusters→BLAS work on OptiX
  - Add OptiX-only smoke tests, e.g, one `*Args` record in a device buffer → build → verify non‑zero output handle(s)/sizes; log basic stats
  - Use `reference/optix-cluster-example/` as guidance for field packing and expected build behavior
- [ ] Step 4.1: Convert some of the sgl_test smoke tests above into slang-rhi tests in the slang-rhi submodule
  - Identify sgl cluster accel tests that might make more sense in slang-rhi and propose a subset to move
  - Once agreed upon, convert these tests to slang-rhi and remove them from sgl
  - Acceptance: slang-rhi-tests passes with a test filter for the new tests
- [ ] Step 5: sgl conversion + example path
  - Acceptance: guarded example path runs; feature‑check gates code path
  - Example: triangles → clusters → BLAS, behind `device->has_feature("cluster-acceleration-structure")`; print handle count/size
  - Location: `examples/clusters/simple_unstructured` (or extend an existing raytracing example)
  - Details (concise):
    - Feature gate and entry: add example path, guard all work on `Feature::cluster_acceleration_structure`.
    - Device ABI: create `cluster_accel_abi.slang` with packed u32/u64 Args (TrianglesArgs, ClustersArgs). Host treats buffers as opaque; optional tiny host mirror for tests/tools.
    - Flow: kernels write N TrianglesArgs → global_barrier → sizes → build CLAS; read 8-byte handles from start of result buffer (handle table), then build BLASFromCLAS using a single ClustersArgs pointing at that handle table.
    - Handles: implicit mode packs 8-byte handles at the start of the result; outputs follow at a 128-byte aligned offset.
    - Validation: if feature/version missing → skip; missing/zero required limits → error; basic asserts (sizes > 0; first handle non‑zero; BLAS output non‑zero).
    - Optional follow‑up: tiny OptiX-only raytrace smoke (single ray, assert hit) after CLAS/BLAS build.
- [ ] Step 6: Templates (unstructured)
  - Acceptance: templates build path works on OptiX; outputs are device addresses (no object types)


## OptiX/Vulkan/DX References
- A reference copy of OptiX headers such as optix_host.h can be found in reference/optix-include/
- for Vulkan: reference/vk-extension
- for DX: reference/nvapi
- These are our three backends; the RHI surface for clusters must remain cross‑compatible. When terminology or behavior is ambiguous, stop and ask
 - OptiX cluster samples:
    reference/optix-cluster-example/ (host/device flow for unstructured clusters)
    reference/optix-cluster-example-structured/ (structured grid clusters, but could be adapted to unstructured)

## Agent quickstart (starting mid-stream)
- Identify current step:
  - Read the "Session checklist" above; pick the first unchecked item.
  - Read that step’s "Acceptance" bullets; aim only for those.
- Find where to work:
  - Headers/API: `external/slang-rhi/include/slang-rhi.h`
  - RHI stubs/defaults: `external/slang-rhi/src/device.h/.cpp`, `external/slang-rhi/src/command-buffer.h/.cpp`, `external/slang-rhi/src/debug-layer/*`
  - sgl mirrors/wrappers: `src/sgl/device/*.h/.cpp`, `src/sgl/device/types.h`, `src/sgl/device/command.h/.cpp`
 - Implementation rules (MVP):
  - Feature: only `"cluster-acceleration-structure"` is exposed and defaults off.
  - OMM: not exposed; all OMM fields must be zero/null.
  - Backends other than OptiX: return NotImplemented/NotAvailable.
- Done criteria per session:
  - Code compiles; new symbols link.
  - Acceptance bullets for the chosen step are satisfied.
  - Do not pre-implement later steps; keep changes scoped.


## Additional details

### RHI API (additions)
- Build types: triangles→CLAS, templates→CLAS, CLAS→BLAS (plus templates-from-triangles/grids)
- Modes: implicit (pool + handles), explicit (dest addresses, optional echoed handles), get-sizes
- Methods: `getClusterAccelerationSizes`, `buildClusterAcceleration`
- Outputs: device addresses only (no object types); BLAS consumes addresses from handles/dest arrays

### sgl layer
- Mirror enums/structs with `SGL_ENUM_*`; add `build_cluster_acceleration(const ClusterAccelBuildDesc&)` wrapper.
- Feature-gate public API on `device->has_feature("cluster-acceleration-structure")`.

### Validation and errors
- Feature absent on device: NotAvailable; not implemented on backend: NotImplemented; enforce buffer sizes/strides/formats.
