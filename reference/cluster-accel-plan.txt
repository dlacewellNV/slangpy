### Cluster Acceleration Structure – Working Plan

## High-level outline
- Goal: Add portable cluster acceleration structure support to `slang-rhi` and `sgl`, OptiX backend first. No device-side copies for indirect args.
- Feature gates:
  - Core clusters and templates: “cluster-acceleration-structure” (in the existing ray tracing section)
- MVP scope:
  - Build types: CLASFromTriangles, BLASFromCLAS
  - Include unstructured TemplatesFromTriangles and CLASFromTemplates in headers now (core feature), implement in a follow-up local stage
  - Exclude structured grid clusters (OptiX-only) from common API for now

## CRITICAL: device-args ABI (zero‑copy)
- ABI objects in device buffers; backends forward them without per-field translation.
- Fixed-stride, trivially copyable PODs with explicit alignment/padding; only scalars and 64‑bit device addresses.
- Single cross-backend definition (OptiX/Vulkan/DX share the same layout). Match the driver ABI bitwise.
- No C/C++ bitfields. Use packed integers (`u32`/`u64`) with SHIFT/MASK helpers (host/device share the same constants).
- Headers: one device-only header (`cluster_accel_abi.slang`) defines structs + pack/unpack. Host treats buffers as opaque. Optional tiny host mirror for tests/tools only.
- OMM-related fields present in vendor ABIs must be zero in MVP.
- Host-side Desc `next`: allowed on host Desc only; in MVP must be null; unknown → UnsupportedExtension. Device-args never include `next`.
- Kernels write args; insert a UAV/global barrier before the build that consumes them; ensure buffer visibility for the backend.

## Session checklist (tick as you go)
- [X] Step 1: RHI headers — compile-only
  - Acceptance: headers compile; device/encoder stubs link; feature name recognized
- [X] Step 2: sgl headers — compile-only
  - Acceptance: sgl compiles; converter builds; encoder exposes method
- [X] Step 3: Feature wiring — defaults off
  - Acceptance: feature registered in RHI and mirrored in sgl; defaults off
- [X] Step 4: OptiX backend — clusters MVP
  - Acceptance: sizes/build for triangles→clusters and clusters→BLAS work on OptiX
  - Add OptiX-only smoke tests, e.g, one `*Args` record in a device buffer → build → verify non‑zero output handle(s)/sizes; log basic stats
  - Use `reference/optix-cluster-example/` as guidance for field packing and expected build behavior
- [X] Step 4.1: Convert the sgl_test smoke tests above into slang-rhi tests in the slang-rhi submodule
  - Acceptance: slang-rhi-tests passes with a test filter for the new tests
  [X] Step 4.2: Expose a flag on the raytracing pipeline to enable clusters.  As reference, consult the optix/vk/dx apis in the reference directories mentioned later in this document.
- [X] Step 5: new sgl cluster example
  - Acceptance: example runs under feature gate; logs CLAS/BLAS sizes; renders an image.
  - Implemented at `examples/raytracing_pipeline_clusters`: triangles → CLAS → BLAS → TLAS → shoot rays.
  - Bootstrap notes: feature gate only; clusters flag on pipeline; device‑args written then global barrier; result buffer starts with 8‑byte handles; multi‑triangle clusters (two strips) share an index buffer with per‑cluster vertex base offsets.

- [X] Step 6: explicit CLAS build mode (user‑provided destinations)
  - Acceptance: enum selects Explicit; OptiX builds each CLAS into caller‑provided addresses; returns handles/sizes when requested; GetSizes path works to pre‑size destinations; existing Implicit path unchanged
  - RHI surface: ensure build mode enum has Implicit/Explicit/GetSizes; extend build desc with explicit fields: `destAddressesBuffer` (device address of array), `destAddressesStrideInBytes` (u32); optional `outputHandlesBuffer`/`outputHandlesStrideInBytes`, optional `outputSizesBuffer`/`outputSizesStrideInBytes`. Mutually exclusive with Implicit fields; debug‑layer validates exclusivity, presence, alignment (>=8), and strides
  - sgl layer: mirror enum/desc; wrapper forwards explicit fields; default mode remains Implicit for back‑compat
  - Backend (OptiX): route Explicit to `OptixClusterAccelBuildModeDescExplicitDest` with temp buffer; implement GetSizes via `OptixClusterAccelBuildModeDescGetSize` in a dry‑run call; verify mode maps 1:1 to OptiX build mode
  - Other backends: Vulkan/DX return NotImplemented/NotAvailable for Explicit/GetSizes in MVP
  - Tests (slang‑rhi): OptiX‑only
    - Explicit build of 2 CLAS: call GetSizes → allocate one big buffer → fill `destAddressesBuffer` with per‑CLAS offsets → build Explicit → assert non‑zero handles and sizes and distinct destinations
    - Validation negatives: missing `destAddressesBuffer`, zero/odd stride, setting both Implicit and Explicit fields → expect validation error
  - Docs: clarify mode semantics and when to prefer GetSizes+Explicit vs Implicit

- [ ] Step 6.5: SGL extensions for Step 6 (modes + wrappers)
  - Acceptance: existing example `examples/raytracing_pipeline_clusters` remains unchanged for Implicit; new Explicit/GetSizes desc fields available; default behavior preserves current implicit packing
  - SGL API:
    - Add `ClusterAccelBuildMode { Implicit, Explicit, GetSizes }` (default Implicit). If `explicit.destAddressesBuffer` is set and mode omitted, infer Explicit
    - Extend `ClusterAccelBuildDesc` with three mode‑specific sub‑descs mirroring OptiX: `implicit`, `explicitDest`, `getSizes`; keep shared `argsArray/argsCount/argsStride`
  - Implicit wrapper behavior (default/simple): keep single‑arena packing; no explicit handles params required at high level. Internally point `outputHandlesBuffer` (and optionally `outputSizesBuffer`) to subranges of the provided result buffer
  - Implicit advanced (opt‑in): allow apps to supply separate `outputHandlesBuffer` and/or `outputSizesBuffer`; validation ensures proper stride/alignment; if unset, use default packing
  - Explicit behavior: require `destAddressesBuffer` (+ stride). `outputHandlesBuffer` is required by OptiX; default to aliasing it to `destAddressesBuffer` (handles overwrite input addresses). Accept a distinct `outputHandlesBuffer` if the app wants to preserve original destinations. `outputSizesBuffer` remains optional
  - GetSizes helper: expose a simple helper to fill a sizes array; optional higher‑level helper that performs GetSizes, plans placements, fills `destAddressesBuffer`, and then issues Explicit build
  - Validation: enforce mutual exclusivity of Implicit vs Explicit fields; check alignment (>=8) and strides; error if both aliasing and separate buffers are specified inconsistently
  - Docs: note that for CLAS/templates a handle equals the device address; for GAS‑from‑CLAS the handle is an opaque traversable; clarify aliasing rules and when to use separate handles buffer
- [ ] Step 7: slang‑rhi cluster tests (build‑and‑shoot)
-  - Acceptance: tests pass; OptiX‑only tests skip elsewhere.
-  - Canonicalize ABI in slang‑rhi (device header + tiny host mirror), u32/u64 POD only.
-  - Tests:
-    - Build‑and‑shoot: two clusters (shared indices, per‑cluster vertex base), BLASFromCLAS with 2 handles, TLAS, clusters pipeline flag; raygen writes barycentrics; assert CLAS/BLAS non‑zero and two horizontal hit bands.
-    - Device‑args variant: write `TrianglesArgs` on device, insert global barrier, then build CLAS; verify parity with host‑filled args.
-  - Optional: record `GetClusterID` at a known pixel.
- [ ] Step 8: Templates (unstructured)
  - Acceptance: templates build path works on OptiX; outputs are device addresses (no object types)
  - Note: refactor per-op limits to a discriminated union keyed by op (mirror OptiX/Vulkan/NVAPI patterns)


## OptiX/Vulkan/DX References
- A reference copy of OptiX headers such as optix_host.h can be found in reference/optix-include/
- for Vulkan: reference/vk-extension
- for DX: reference/nvapi
- These are our three backends; the RHI surface for clusters must remain cross‑compatible. When terminology or behavior is ambiguous, stop and ask
 - OptiX cluster samples:
    reference/optix-cluster-example/ (host/device flow for unstructured clusters)
    reference/optix-cluster-example-structured/ (structured grid clusters, but could be adapted to unstructured)

## Agent quickstart (starting mid-stream)
- Identify current step:
  - Read the "Session checklist" above; pick the first unchecked item.
  - Read that step’s "Acceptance" bullets; aim only for those.
- Find where to work:
  - Headers/API: `external/slang-rhi/include/slang-rhi.h`
  - RHI stubs/defaults: `external/slang-rhi/src/device.h/.cpp`, `external/slang-rhi/src/command-buffer.h/.cpp`, `external/slang-rhi/src/debug-layer/*`
  - sgl mirrors/wrappers: `src/sgl/device/*.h/.cpp`, `src/sgl/device/types.h`, `src/sgl/device/command.h/.cpp`
 - Implementation rules (MVP):
  - Feature: only `"cluster-acceleration-structure"` is exposed and defaults off.
  - OMM: not exposed; all OMM fields must be zero/null.
  - Backends other than OptiX: return NotImplemented/NotAvailable.
- Done criteria per session:
  - Code compiles; new symbols link.
  - Acceptance bullets for the chosen step are satisfied.
  - Do not pre-implement later steps; keep changes scoped.


## Additional details

### RHI API (additions)
- Build types: triangles→CLAS, templates→CLAS, CLAS→BLAS (plus templates-from-triangles/grids)
- Modes: implicit (pool + handles), explicit (dest addresses, optional echoed handles), get-sizes
- Methods: `getClusterAccelerationSizes`, `buildClusterAcceleration`
- Outputs: device addresses only (no object types); BLAS consumes addresses from handles/dest arrays

### sgl layer
- Mirror enums/structs with `SGL_ENUM_*`; add `build_cluster_acceleration(const ClusterAccelBuildDesc&)` wrapper.
- Feature-gate public API on `device->has_feature("cluster-acceleration-structure")`.

### Validation and errors
- Feature absent on device: NotAvailable; not implemented on backend: NotImplemented; enforce buffer sizes/strides/formats.
