### Cluster Acceleration Structure – Working Plan

## High-level outline
- Goal: Add portable cluster acceleration structure support to `slang-rhi` and `sgl`, OptiX backend first. No device-side copies for indirect args.
- Feature gates:
  - Core clusters and templates: “cluster-acceleration-structure” (in the existing ray tracing section)
- MVP scope:
  - Build types: CLASFromTriangles, BLASFromCLAS
  - Include unstructured TemplatesFromTriangles and CLASFromTemplates in headers now (core feature), implement in a follow-up local stage
  - Exclude structured grid clusters (OptiX-only) from common API for now

## CRITICAL: device-args ABI (zero‑copy)
- ABI objects in device buffers; backends forward them without per-field translation.
- Fixed-stride, trivially copyable PODs with explicit alignment/padding; only scalars and 64‑bit device addresses.
- Single cross-backend definition (OptiX/Vulkan/DX share the same layout). Match the driver ABI bitwise.
- No C/C++ bitfields. Use packed integers (`u32`/`u64`) with SHIFT/MASK helpers (host/device share the same constants).
- Headers: one device-only header (`cluster_accel_abi.slang`) defines structs + pack/unpack. Host treats buffers as opaque. Optional tiny host mirror for tests/tools only.
- OMM-related fields present in vendor ABIs must be zero in MVP.
- Host-side Desc `next`: allowed on host Desc only; in MVP must be null; unknown → UnsupportedExtension. Device-args never include `next`.
- Kernels write args; insert a UAV/global barrier before the build that consumes them; ensure buffer visibility for the backend.

## Session checklist (tick as you go)
- [X] Step 1: RHI headers — compile-only
  - Acceptance: headers compile; device/encoder stubs link; feature name recognized
- [X] Step 2: sgl headers — compile-only
  - Acceptance: sgl compiles; converter builds; encoder exposes method
- [X] Step 3: Feature wiring — defaults off
  - Acceptance: feature registered in RHI and mirrored in sgl; defaults off
- [X] Step 4: OptiX backend — clusters MVP
  - Acceptance: sizes/build for triangles→clusters and clusters→BLAS work on OptiX
  - Add OptiX-only smoke tests, e.g, one `*Args` record in a device buffer → build → verify non‑zero output handle(s)/sizes; log basic stats
  - Use `reference/optix-cluster-example/` as guidance for field packing and expected build behavior
- [X] Step 4.1: Convert the sgl_test smoke tests above into slang-rhi tests in the slang-rhi submodule
  - Acceptance: slang-rhi-tests passes with a test filter for the new tests
  [X] Step 4.2: Expose a flag on the raytracing pipeline to enable clusters.  As reference, consult the optix/vk/dx apis in the reference directories mentioned later in this document.
- [X] Step 5: new sgl cluster example
  - Acceptance: example runs under feature gate; logs CLAS/BLAS sizes; renders an image.
  - Implemented at `examples/raytracing_pipeline_clusters`: triangles → CLAS → BLAS → TLAS → shoot rays.
  - Bootstrap notes: feature gate only; clusters flag on pipeline; device‑args written then global barrier; result buffer starts with 8‑byte handles; multi‑triangle clusters (two strips) share an index buffer with per‑cluster vertex base offsets.

- [X] Step 6: Explicit CLAS mode (context only)
  - Add Explicit/GetSizes modes alongside Implicit; Explicit uses per‑CLAS destination addresses; GetSizes for pre‑sizing
  - OptiX path implemented; DX/VK NotAvailable for now

- [X] Step 6.5: SGL (context only)
  - Build modes and mode‑specific descs added; required buffers live in the desc (Implicit/Explicit/GetSizes)
  - Example updated; backend consumes buffers from desc

- [X] Step 6.6: RHI/backend API cleanup
  - Acceptance: RHI `buildClusterAccelerationStructure` no longer takes `scratch/result` parameters; backends consume buffers exclusively from the build desc
  - Update: remove scratch/result from RHI interface and implementations (OptiX, debug layer, command paths); adjust tests/examples to set buffers in desc
  - Validation: enforce required per‑mode buffers at RHI layer; meaningful errors if missing/misaligned
  - SGL convenience: think about a small helper to compute handles padding and populate implicit desc fields (handles/output/temp) from a single buffer + arg count, to keep samples concise
- [ ] Step 7: slang‑rhi cluster tests (build‑and‑shoot)
-  - Acceptance: tests pass; OptiX‑only tests skip elsewhere.
-  - Canonicalize ABI in slang‑rhi (device header + tiny host mirror), u32/u64 POD only.
-  - Tests:
-    - Build‑and‑shoot: two clusters (shared indices, per‑cluster vertex base), BLASFromCLAS with 2 handles, TLAS, clusters pipeline flag; raygen writes barycentrics; assert CLAS/BLAS non‑zero and two horizontal hit bands.
-    - Device‑args variant: write `TrianglesArgs` on device, insert global barrier, then build CLAS; verify parity with host‑filled args.
-  - Optional: record `GetClusterID` at a known pixel.
- [ ] Step 8: Templates (unstructured)
  - Acceptance: templates build path works on OptiX; outputs are device addresses (no object types)
  - Note: refactor per-op limits to a discriminated union keyed by op (mirror OptiX/Vulkan/NVAPI patterns)


## OptiX/Vulkan/DX References
- A reference copy of OptiX headers such as optix_host.h can be found in reference/optix-include/
- for Vulkan: reference/vk-extension
- for DX: reference/nvapi
- These are our three backends; the RHI surface for clusters must remain cross‑compatible. When terminology or behavior is ambiguous, stop and ask
 - OptiX cluster samples:
    reference/optix-cluster-example/ (host/device flow for unstructured clusters)
    reference/optix-cluster-example-structured/ (structured grid clusters, but could be adapted to unstructured)

## Agent quickstart (starting mid-stream)
- Identify current step:
  - Read the "Session checklist" above; pick the first unchecked item.
  - Read that step’s "Acceptance" bullets; aim only for those.
- Find where to work:
  - Headers/API: `external/slang-rhi/include/slang-rhi.h`
  - RHI stubs/defaults: `external/slang-rhi/src/device.h/.cpp`, `external/slang-rhi/src/command-buffer.h/.cpp`, `external/slang-rhi/src/debug-layer/*`
  - sgl mirrors/wrappers: `src/sgl/device/*.h/.cpp`, `src/sgl/device/types.h`, `src/sgl/device/command.h/.cpp`
 - Implementation rules (MVP):
  - Feature: only `"cluster-acceleration-structure"` is exposed and defaults off.
  - OMM: not exposed; all OMM fields must be zero/null.
  - Backends other than OptiX: return NotImplemented/NotAvailable.
- Done criteria per session:
  - Code compiles; new symbols link.
  - Acceptance bullets for the chosen step are satisfied.
  - Do not pre-implement later steps; keep changes scoped.


## Additional details

### RHI API (additions)
- Build types: triangles→CLAS, templates→CLAS, CLAS→BLAS (plus templates-from-triangles/grids)
- Modes: implicit (pool + handles), explicit (dest addresses, optional echoed handles), get-sizes
- Methods: `getClusterAccelerationSizes`, `buildClusterAcceleration`
- Outputs: device addresses only (no object types); BLAS consumes addresses from handles/dest arrays

### sgl layer
- Mirror enums/structs with `SGL_ENUM_*`; add `build_cluster_acceleration(const ClusterAccelBuildDesc&)` wrapper.
- Feature-gate public API on `device->has_feature("cluster-acceleration-structure")`.

### Validation and errors
- Feature absent on device: NotAvailable; not implemented on backend: NotImplemented; enforce buffer sizes/strides/formats.
